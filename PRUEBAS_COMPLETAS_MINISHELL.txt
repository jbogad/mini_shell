# üß™ PRUEBAS COMPLETAS PARA MINISHELL

## üìã √çNDICE
1. [BUILT-INS](#built-ins)
2. [EXEC (Ejecuci√≥n de comandos externos)](#exec)
3. [PIPES](#pipes)
4. [REDIRECTIONS](#redirections)
5. [COMBINACIONES COMPLEJAS](#combinaciones)
6. [CASOS EDGE](#casos-edge)

---

## üèóÔ∏è BUILT-INS

### 1Ô∏è‚É£ **ECHO**

#### ‚úÖ Casos b√°sicos:
```bash
echo hello
echo "hello world"
echo 'single quotes'
echo hello world multiple args
echo ""
echo ''
```

#### ‚úÖ Flag -n (sin newline):
```bash
echo -n hello
echo -n "no newline"
echo -n
echo -nnnnn hello (m√∫ltiples -n)
```

#### ‚úÖ Casos edge:
```bash
echo -n -n -n hello
echo -N hello (no deber√≠a funcionar como -n)
echo --n hello (no deber√≠a funcionar como -n)
echo - hello
echo -
```

#### ‚úÖ Esperado:
- `echo hello` ‚Üí `hello\n`
- `echo -n hello` ‚Üí `hello` (sin newline)
- `echo ""` ‚Üí `\n` (solo newline)

---

### 2Ô∏è‚É£ **PWD**

#### ‚úÖ Casos b√°sicos:
```bash
pwd
pwd extra args (deber√≠a ignorar argumentos)
```

#### ‚úÖ Casos edge:
```bash
pwd -L (con flags, deber√≠a ignorar)
pwd --help (deber√≠a ignorar)
```

#### ‚úÖ Esperado:
- Siempre imprime el directorio actual + newline

---

### 3Ô∏è‚É£ **CD**

#### ‚úÖ Casos b√°sicos:
```bash
cd /tmp
cd ..           SI QUE FUNCIONA
cd .            SI QUE FUNCIONA -> PERO NO SE COMO ES
cd $HOME        NO SE SI FUNCIONA
cd (sin argumentos, ir a HOME) BUCLE INFINITO
```

#### ‚úÖ Rutas relativas y absolutas:
```bash
cd src
cd ./src
cd ../
cd /usr/bin
cd ../../
```

#### ‚úÖ Casos de error:
```bash
cd /directorio/inexistente
cd archivo_no_directorio
cd /root (sin permisos)
```

#### ‚úÖ Variables de entorno:
```bash
export TEST_DIR=/tmp
cd $TEST_DIR
```

#### ‚úÖ Esperado:
- Cambio exitoso: sin output, $? = 0
- Error: mensaje como bash + $? = 1

---

### 4Ô∏è‚É£ **EXPORT**

#### ‚úÖ Sin argumentos (mostrar variables):
```bash
export
```

#### ‚úÖ Crear/modificar variables:
```bash
export VAR=value
export VAR="value with spaces"
export VAR='single quotes'
export VAR=""
export VAR=
export PATH="/new/path:$PATH"
```

#### ‚úÖ M√∫ltiples variables:
```bash
export VAR1=val1 VAR2=val2 VAR3=val3
```

#### ‚úÖ Casos de error:
```bash
export 123VAR=value (nombre inv√°lido)
export VAR*=value (caracteres inv√°lidos)
export =value (sin nombre)
export VAR==value (doble =)
```

#### ‚úÖ Esperado:
- √âxito: sin output, variable en entorno
- Error: "export: name: not a valid identifier"

---

### 5Ô∏è‚É£ **UNSET**

#### ‚úÖ Casos b√°sicos:
```bash
export TEST=value
unset TEST
echo $TEST (deber√≠a estar vac√≠o)
```

#### ‚úÖ M√∫ltiples variables:
```bash
export A=1 B=2 C=3
unset A B C
```

#### ‚úÖ Variables inexistentes:
```bash
unset NONEXISTENT (no deber√≠a dar error)
```

#### ‚úÖ Casos de error:
```bash
unset 123VAR (nombre inv√°lido)
unset VAR* (caracteres inv√°lidos)
```

#### ‚úÖ Esperado:
- √âxito: sin output, variable eliminada
- Error: mensaje de error + $? = 1

---

### 6Ô∏è‚É£ **ENV**

#### ‚úÖ Casos b√°sicos:
```bash
env
env | grep USER
env | wc -l
```

#### ‚úÖ Con argumentos extra:
```bash
env args extra (deber√≠a ignorar)
```

#### ‚úÖ Esperado:
- Lista todas las variables en formato NAME=VALUE

---

### 7Ô∏è‚É£ **EXIT**

#### ‚úÖ Sin argumentos:
```bash
exit
```

#### ‚úÖ Con c√≥digo de salida:
```bash
exit 0
exit 1
exit 42
exit 255
```

#### ‚úÖ Casos de error:
```bash
exit abc (argumento no num√©rico)
exit 256 (fuera de rango 0-255)
exit -1 (negativo)
exit 1 2 3 (demasiados argumentos)
```

#### ‚úÖ Esperado:
- `exit` ‚Üí c√≥digo 0
- `exit N` ‚Üí c√≥digo N
- Error: mensaje + salir con c√≥digo 2

---

## üöÄ EXEC (Comandos externos)

### 1Ô∏è‚É£ **Comandos b√°sicos del sistema:**
```bash
ls
ls -la
cat /etc/passwd
grep root /etc/passwd
wc -l /etc/passwd
head -5 /etc/passwd
tail -3 /etc/passwd
```

### 2Ô∏è‚É£ **Comandos con argumentos:**
```bash
ls -la /tmp
cat file1.txt file2.txt
grep -n "pattern" file.txt
```

### 3Ô∏è‚É£ **Comandos inexistentes:**
```bash
comando_inexistente
/bin/comando_inexistente
./programa_inexistente
```

### 4Ô∏è‚É£ **Paths absolutos vs relativos:**
```bash
/bin/ls
./mi_programa (si existe)
ls (encontrar en PATH)
```

### 5Ô∏è‚É£ **Esperado:**
- √âxito: output del comando + c√≥digo de salida correcto
- Error: "command not found" + c√≥digo 127

---

## üîÄ PIPES

### 1Ô∏è‚É£ **Pipes simples:**
```bash
echo hello | cat
ls | wc -l
cat /etc/passwd | grep root
echo "test line" | wc -w
```

### 2Ô∏è‚É£ **Pipes m√∫ltiples:**
```bash
ls | head -5 | tail -2
cat /etc/passwd | grep bash | wc -l
echo -e "a\nb\nc" | sort | uniq
```

### 3Ô∏è‚É£ **Pipes con built-ins:**
```bash
pwd | cat
echo hello | cat | cat
env | grep PATH
```

### 4Ô∏è‚É£ **Errores de sintaxis:**
```bash
| ls (pipe al inicio)
ls | (pipe al final)
ls || pwd (pipes dobles)
```

### 5Ô∏è‚É£ **Esperado:**
- Pipe v√°lido: output correcto
- Error sintaxis: "syntax error near unexpected token `|'"

---

## üìÅ REDIRECTIONS

### 1Ô∏è‚É£ **Output redirection (>):**
```bash
echo hello > file.txt
ls > files.txt
pwd > current_dir.txt
echo "overwrite" > file.txt
```

### 2Ô∏è‚É£ **Append redirection (>>):**
```bash
echo line1 > file.txt
echo line2 >> file.txt
echo line3 >> file.txt
```

### 3Ô∏è‚É£ **Input redirection (<):**
```bash
echo "content" > input.txt
cat < input.txt
wc -l < input.txt
```

### 4Ô∏è‚É£ **Heredoc (<<):**
```bash
cat << EOF
line 1
line 2
EOF

wc -l << END
test
lines
END
```

### 5Ô∏è‚É£ **Redirections con variables:**
```bash
export FILE=output.txt
echo hello > $FILE
cat < $FILE
```

### 6Ô∏è‚É£ **Casos de error:**
```bash
echo hello > /root/file.txt (sin permisos)
cat < nonexistent.txt (archivo inexistente)
```

---

## üî• COMBINACIONES COMPLEJAS

### 1Ô∏è‚É£ **Pipes + Redirections:**
```bash
echo hello | cat > output.txt
ls | grep txt > text_files.txt
cat < input.txt | wc -l > count.txt
```

### 2Ô∏è‚É£ **Multiple redirections:**
```bash
echo test > file1.txt > file2.txt (solo file2.txt)
```

### 3Ô∏è‚É£ **Built-ins + Redirections:**
```bash
pwd > current.txt
export > all_vars.txt
env > environment.txt
echo $PATH > path.txt
```

### 4Ô∏è‚É£ **Pipes largos + Redirections:**
```bash
ls -la | grep txt | wc -l > txt_count.txt
cat /etc/passwd | grep bash | cut -d: -f1 > bash_users.txt
```

---

## üéØ CASOS EDGE

### 1Ô∏è‚É£ **Variables de entorno:**
```bash
export TEST="ls -la"
$TEST (deber√≠a ejecutar ls -la)
echo $TEST
echo "$TEST"
echo '$TEST' (literal)
```

### 2Ô∏è‚É£ **Espacios y quotes:**
```bash
echo "hello world"
echo 'hello world'
echo "hello 'world'"
echo 'hello "world"'
```

### 3Ô∏è‚É£ **Empty commands:**
```bash
""
''
   (solo espacios)
```

### 4Ô∏è‚É£ **Se√±ales (Ctrl+C, Ctrl+D):**
```bash
# Durante ejecuci√≥n de comando
cat (luego Ctrl+C)
cat (luego Ctrl+D)
```

### 5Ô∏è‚É£ **Exit status ($?):**
```bash
echo $? (deber√≠a ser 0 al inicio)
false
echo $? (deber√≠a ser 1)
true
echo $? (deber√≠a ser 0)
```

---

## üìä SCRIPT DE PRUEBA AUTOMATIZADO

```bash
#!/bin/bash
# Crear este script para probar autom√°ticamente

echo "=== PROBANDO BUILT-INS ==="
echo "Testing echo..."
echo hello
echo -n test

echo "Testing pwd..."
pwd

echo "Testing cd..."
cd /tmp && pwd

echo "Testing export..."
export TEST=value
echo $TEST

echo "Testing env..."
env | grep TEST

echo "Testing unset..."
unset TEST
echo $TEST

echo "=== PROBANDO EXEC ==="
ls
cat /etc/passwd | head -3

echo "=== PROBANDO PIPES ==="
echo hello | cat
ls | wc -l

echo "=== PROBANDO REDIRECTIONS ==="
echo test > testfile.txt
cat testfile.txt
rm testfile.txt

echo "=== PRUEBAS COMPLETADAS ==="
```

---

## ‚úÖ LISTA DE VERIFICACI√ìN

- [ ] Todos los built-ins funcionan correctamente
- [ ] Comandos externos se ejecutan
- [ ] Pipes simples y m√∫ltiples funcionan
- [ ] Todas las redirections funcionan
- [ ] Variables de entorno se expanden
- [ ] Errores de sintaxis se detectan
- [ ] Exit codes son correctos
- [ ] Se√±ales se manejan apropiadamente
- [ ] Memory leaks = 0 (valgrind)
- [ ] Norminette compliance = 100%

¬°Usa este archivo para probar sistem√°ticamente todas las funcionalidades de tu minishell!
